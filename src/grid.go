package main

/*
сетка окна приложения может описываться json
{
строка:{
	ширина: 100 , // ширина строки в пикселях
	высота: 100 , // высота строки в пикселях
	элементы:[], // элементы в строке
	выравниваниеПоВертикали: "центр, лево, право, растянуть, пространствоМежду, пространствоРавномерно , пространствоВокруг" // выравнивание элементов в строке
	выравниваниеПоГоризонтали: "центр, лево, право, растянуть, пространствоМежду, пространствоРавномерно , пространствоВокруг" // выравнивание элементов в строке
} // элменты в этом блоке распологаются в строку друг за другом
 столбец:{
	ширина: 100 , // ширина строки в пикселях
	высота: 100 , // высота строки в пикселях
	элементы:[], // элементы в строке
	выравниваниеПоВертикали: "центр, лево, право, растянуть, пространствоМежду, пространствоРавномерно , пространствоВокруг" // выравнивание элементов в строке
	выравниваниеПоГоризонтали: "центр, лево, право, растянуть, пространствоМежду, пространствоРавномерно , пространствоВокруг" // выравнивание элементов в строке
} // элменты в этом блоке распологаются вертиклаьно друг за другом

}

 "пространствоМежду" Элементы равномерно распределяются по главной оси, при этом первый элемент находится в начале, а последний — в конце.

"пространствоРавномерно" Элементы равномерно распределяются по главной оси, при этом свободное пространство между элементами и между элементами и краями контейнера одинаково.

 "пространствоВокруг" Элементы равномерно распределяются по главной оси, при этом свободное пространство вокруг каждого элемента (до соседних элементов и краев контейнера) одинаково. Это означает, что пространство между элементами в два раза больше, чем пространство между элементами и краями контейнера.
*/

// func ПрисоединитьПотоки(текущийПоток, целевойПоток uint32, присоединить bool) bool {
// 	присоединитьЗначение := 0
// 	if присоединить {
// 		присоединитьЗначение = 1
// 	}

// 	ret, ret2, err := AttachThreadInput.Call(
// 		uintptr(текущийПоток),
// 		uintptr(целевойПоток),
// 		uintptr(присоединитьЗначение),
// 	)
// 	Инфо("ПрисоединитьПотоки %+v  %+v  %+v \n", ret, ret2, err)

// 	return ret != 0
// }
// func ПолучитьАктивноеОкноИКаретку() (win.HWND, win.RECT) {
// 	// Получаем хендл активного окна
// 	активноеОкно := win.GetForegroundWindow()

// 	// Получаем ID потока активного окна
// 	_, активныйПоток := активноеОкно.GetWindowThreadProcessId()

// 	// Получаем ID текущего потока
// 	текущийПоток := win.GetCurrentThreadId()

// 	// Присоединяемся к потоку активного окна для получения информации о каретке
// 	ПрисоединитьПотоки(текущийПоток, активныйПоток, true)
// 	defer ПрисоединитьПотоки(текущийПоток, активныйПоток, false)

// 	// Получаем позицию каретки
// 	// var позицияКаретки win.RECT
// 	позицияКаретки := win.GetCaretPos()
// 	Инфо("1 позицияКаретки %v активноеОкно %v", позицияКаретки, активноеОкно)
// 	// Преобразуем координаты каретки в экранные координаты
// 	активноеОкно.ClientToScreenRc(&позицияКаретки)
// 	Инфо("2 позицияКаретки %v активноеОкно %v", позицияКаретки, активноеОкно)
// 	return активноеОкно, позицияКаретки
// }

// func GetCaretPosSys() RECT {
// 	var rc RECT
// 	ret, r1, err := syscall.SyscallN(GetCaretPos.Addr(),
// 		uintptr(unsafe.Pointer(&rc)))

// 	Инфо(" ret %+v, r1 %+v, err %+v %+v \n", ret, r1, err, rc)

// 	// if ret == 0 {
// 	// 	panic(errco.ERROR(err))
// 	// }
// 	return rc
// }
