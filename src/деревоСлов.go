package main

import (
	"encoding/json"
	"os"
)

// ДОК: Необходимо реализовать алгоритм, который будет находить и предсказывать слова в соотвествии с набором введёных кодов клавишь и соотвествующим этим кодам наборам букв
/*
var Алвафит = map[ВиртуальныйКод]Кнопка{

	0x51: {0x51, "0x51", map[string][]string{"en": []string{"E", "T"}, "ру": []string{"И", "Б", "Ы"}}},
	0x57: {0x57, "0x57", map[string][]string{"en": []string{"A", "O"}, "ру": []string{"В", "Ь", "Ъ"}}},
	0x45: {0x45, "0x45", map[string][]string{"en": []string{"I", "N"}, "ру": []string{"Д", "Е", "Ё"}}},
	0x52: {0x52, "0x52", map[string][]string{"en": []string{"S", "H"}, "ру": []string{"Ж", "З", "Н"}}},
	0x43: {0x43, "0x43", map[string][]string{"en": []string{".", "["}, "ру": []string{".", "["}}},

	// Второй ряд (4 кнопки)
	0x41: {0x41, "0x41", map[string][]string{"en": []string{"R", "D"}, "ру": []string{"A", "Й"}}},
	0x53: {0x53, "0x53", map[string][]string{"en": []string{"L", "C"}, "ру": []string{"К", "Л"}}},
	0x44: {0x44, "0x44", map[string][]string{"en": []string{"U", "M"}, "ру": []string{"М", "П"}}},
	0x46: {0x46, "0x46", map[string][]string{"en": []string{"W", "F"}, "ру": []string{"О", "Р"}}},
	0x56: {0x56, "0x56", map[string][]string{"en": []string{"{", "\""}, "ру": []string{"{", "\""}}},

	// Третий ряд (4 кнопки)
	0x5A: {0x5A, "0x5A", map[string][]string{"en": []string{"G", "Y"}, "ру": []string{"Ф", "Х", "Э", "Ю"}}},
	0x58: {0x58, "0x58", map[string][]string{"en": []string{"P", "B"}, "ру": []string{"Ц", "Ч", "Ш", "Щ"}}},
	0x54: {0x54, "0x54", map[string][]string{"en": []string{"V", "K"}, "ру": []string{"Р", "С"}}},
	0x47: {0x47, "0x47", map[string][]string{"en": []string{"J", "X", "Q", "Z"}, "ру": []string{"Т", "У"}}},
}

Этот код определяет раскладку клавиатуры для двух языков: английского и русского. Каждая кнопка клавиатуры имеет свой код и соотвествует сразу нескольким символам. При этом одно нажатие кнопки соотвествует одному из символов на кнопке, сочетание кодов соответсуют буквосечтаниям слов, примеру
0x44 0x46 0x51 0x57 0x45 0x47 - соотвествие ПРИВЕТ на русском языке но на английском это должно быть слово которое может состоять из букв 1 буква {"U" или "M"} 2 буква{"W" или  "F"} 3 буква  {"E" или "T"}  4 буква {"A" или  "O"} 5 буква  {"I" или "N"}  6 буква {"J" или "X" или  "Q" или "Z"} если ни одно из существющих слов не соотвествует этому набору кодов то это слово не существует, просто игнорируем для этого языка.



*/

// Трие узел
type Узел struct {
	Ребёнок map[rune]*Узел
	Конец   bool
}

// Трие
type Трие struct {
	Root *Узел
}

// Новый Трие
func НовыйТрие() *Трие {
	return &Трие{Root: &Узел{Ребёнок: make(map[rune]*Узел)}}
}

// Добавить слово
func (т *Трие) ДобавитьСлово(слово string) {
	узел := т.Root
	for _, символ := range слово {
		if _, ок := узел.Ребёнок[символ]; !ок {
			узел.Ребёнок[символ] = &Узел{Ребёнок: make(map[rune]*Узел)}
		}
		узел = узел.Ребёнок[символ]
	}
	узел.Конец = true
}

// Сохранить Трие в файл
func (т *Трие) СохранитьВФайл(путь string) error {
	файл, ошибка := json.Marshal(т)
	if ошибка != nil {
		return ошибка
	}
	return os.WriteFile(путь, файл, 0644)
}

// Загрузить Трие из файла
func ЗагрузитьИзФайла(путь string) (*Трие, error) {
	файл, ошибка := os.ReadFile(путь)
	if ошибка != nil {
		return nil, ошибка
	}
	var т Трие
	ошибка = json.Unmarshal(файл, &т)
	if ошибка != nil {
		return nil, ошибка
	}
	return &т, nil
}

// Поиск слова можно хранить ссылки на узлы, чтобы не искать каждый раз с начала (оптимизация)
// поиск осуществяется по мере ввода символов, и чтобы каждый раз не проходить дерево от корня будет возвращаться ссылка на текущие узлы и при следующем вводе символа будет искаться в этих узлах

// func (т *Трие) ПоискСлова(слово string) bool {
// 	узел := т.Root
// 	for _, символ := range слово {
// 		if _, ок := узел.Ребёнок[символ]; !ок {
// 			return false
// 		}
// 		узел = узел.Ребёнок[символ]
// 	}
// 	return узел.Конец
// }
// Структура для хранения текущих узлов
type ТекущиеУзлы struct {
	Узлы []*Узел
}

// Поиск всех возможных слов, соответствующих введенному набору символов
func (т *Трие) ПоискСлова(слово string, текущиеУзлы *ТекущиеУзлы) []string {
	узлы := текущиеУзлы.Узлы
	if узлы == nil {
		узлы = []*Узел{т.Root}
	}

	новыеУзлы := []*Узел{}
	результаты := []string{}

	for _, узел := range узлы {
		for _, символ := range слово {
			if ребёнок, ок := узел.Ребёнок[символ]; ок {
				новыеУзлы = append(новыеУзлы, ребёнок)
				найтиВсеСлова(ребёнок, string(символ), &результаты)
			}
		}
	}

	текущиеУзлы.Узлы = новыеУзлы
	return результаты
}

// Рекурсивная функция для поиска всех слов, начиная с текущего узла
func найтиВсеСлова(узел *Узел, текущееСлово string, результаты *[]string) {
	if узел.Конец {
		*результаты = append(*результаты, текущееСлово)
	}
	for символ, ребёнок := range узел.Ребёнок {
		найтиВсеСлова(ребёнок, текущееСлово+string(символ), результаты)
	}
}